\section{Introduction}
Static analysis of binaries is inherently challenging because the compilation
process discards most high-level program information\cite{compiler-level-ir}, such as variable and
function names, type definitions, and source-level control structures. Binary
lifters translate binaries into an intermediate representation (IR) to address
this limitation, and they have consequently attracted significant attention.

Among various forms of IR, many lifteres target the LLVM Intermediate
Representation(LLVM IR), a low-level intermediate code within the LLVM compiler
infrastructure due to its extensive optimization and transformation
capabilities. However, binary lifters do not always generate IR that is equally
suitable for program analysis. In general, binary lifters produce two distinct
styles of IR: high-level IR (HIR) and emulation-style IR (EIR). 

A recent study evaluated four LLVM IR based binary lifters\cite{snp-sok}. In that study, each
binary was lifted by all four tools and evaluated in terms of analysis
suitability and functional correctness. The results varied significantly
depending on the IR style. HIR demonstrated strong analysis suitability but
lower functional correctness, whereas EIR achieved higher functional
correctness, but was less suitable for analysis.

\begin{listing}[ht]
\begin{minted}[linenos, numbers=left, frame=lines, framesep=2mm, xleftmargin=10pt, fontsize=\footnotesize]{llvm}
define i32 @main() {
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store i32 99, i32* %a, align 4
  store i32 9000, i32* %b, align 4
  %0 = load i32, i32* %a, align 4
  %1 = load i32, i32* %b, align 4
  %sum = add nsw i32 %0, %1
}
\end{minted}
\caption{High-level style LLVM-IR (Clang generated)}
\label{lst:hir}
\end{listing}

\begin{listing}[ht]
\begin{minted}[linenos, numbers=left, frame=lines, framesep=2mm, xleftmargin=10pt, fontsize=\footnotesize]{llvm}
define i32 @Func_main(i32 %arg_esp) {
  %tmp1 = add i32 %arg_esp, -8
  %1 = inttoptr i32 %tmp1 to i32*
  store i32 99, i32* %1, align 4
  %tmp2 = add i32 %arg_esp, -12
  %2 = inttoptr i32 %tmp2 to i32*
  store i32 9000, i32* %2, align 4
  %3 = load i32, i32* %1, align 4 
  %tmp3 = add i32 %3, 9000
}
\end{minted}
\caption{Emulation style LLVM-IR (Binrec generated)}
\label{lst:eir}
\end{listing}

As shown in \autoref{lst:hir} and \autoref{lst:eir}, EIR emulates machine code
more closely through the use of a virtual stack, while HIR preserves more
semantic information such as type annotations and explicit local variables.
Because the virtual stack mimics program behavior, EIR preserves functional
correctness effectively. However, the absence of explicit variables and other
high-level information reduces its suitability for analysis.

In this study, we propose a method for transforming EIR into HIR. Although EIR
preserves program semantics well due to its emulated stack, this same structure
obscures the high-level information required for analysis. Our goal is to
eliminate the virtual stack in EIR and transform the code into HIR while
preserving semantics, thereby combining the functional correctness of EIR with
the analysis suitability of HIR.

For this purpose, we selected BinRec\cite{euro-binrec}, a dynamic lifter, to
generate EIR for transformation. We suggest two methods: 1) Variable recover,
2) Recovery of types

