\section{Approach 1: Variable Recovery}
In EIR generated by BinRec, explicit variables do not exist because the lifter
merely emulates the programâ€™s behavior using a stack. As BinRec is a dynamic
lifter, the executed program paths are directly reflected in the lifted code.
BinRec employs a virtual stack and a variable functioning as a virtual stack
pointer (similar to `esp`), emulating the program using both.
As shown in Fig. , a recurring pattern emerges in the emulation of variables:
the lifter first retrieves the virtual stack address and then stores a value to
that address. For example, \%tmp0 and \%1 exhibit a relationship with the
virtual stack pointer. To detect such relationships between variables, we
designate the virtual stack pointer as symbolic and perform symbolic execution.
This allows us to determine which variables are associated with which offsets
relative to the virtual stack pointer. If multiple variables share the same
offset with respect to the virtual stack pointer, we infer that they reference
the same memory location. In such cases, we consolidate them into a single
variable, thereby simplifying the representation (see example results).
However, this approach has limitations inherent to symbolic execution. Since
symbolic execution is a static analysis technique, it suffers from the path
explosion problem: when the number of possible execution paths becomes too
large, it is infeasible to resolve all relationships between variables. This
issue arises when there are multiple control-flow paths. To mitigate this, we
restrict symbolic execution to the basic block level rather than the
function level, ensuring that only a single path is explored per execution. At
present, this method is effective only for relatively simple cases, but we plan
to extend it to handle more complex scenarios.
