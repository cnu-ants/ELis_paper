\section{Approach 1: Variable Recovery}
In the EIR generated by BinRec, explicit varibales are omitted. And program
behaviour is emulated using a virtual stack and a virtual stack pointer. As a
dynamic binary lifter, BinRec captures only the execution paths that occur at
runtime and reflects them directly in the generated code with virtual stack and
virtual stack pointer.
\begin{listing}[ht]
\begin{minted}[linenos, numbers=left, frame=lines, framesep=2mm, xleftmargin=10pt, fontsize=\footnotesize]{llvm}
define i32 @Func_main(i32 %arg_esp) {
  %tmp0 = add i32 %arg_esp, -4
  %tmp1 = add i32 %arg_esp, -8
  %1 = inttoptr i32 %tmp0 to i32*
  store i32 0, i32* %1, align 4
  %tmp2 = add i32 %tmp1, 4
  %2 = inttoptr i32 %tmp2 to i32*
  store i32 100, i32* %2, align 4
}
\end{minted}
\caption{Example of BinRec generate LLVM-IR}
\label{lst:variablerecover}
\end{listing}

To represent variables in this emulation style, BinRec first computes virtual
stack addresses from the virtual stack pointer and then stores values at those
addresses. As shown in \autoref{lst:variablerecover}, \texttt{\%tmp0} and \texttt{\%tmp1} contain
addresses derived from arithmetic operations on \texttt{\%arg\_esp}, which
serves as the virtual stack pointer. These values are subsequently converted
into pointer variables like \texttt{\%1}, and used as if they were concrete
variables. Moreover, \texttt{\%tmp1} plus 4 yields the same value as
\texttt{\%tmp0}, indicating that multiple temporaries may reference the same
virtual stack location. This observation suggests that such temporaries can be
unified into a single variable to simplify the representation.
So to detect these relationship with variable and virtual stack pointer, we use
symbolic execution. We set virtual stack pointer as symbol and performed
symbolic execution. Then we can get variables relationship. We convert
variables with same relationship into one variable and make it simple. But
there is challenge due to symbolic executionâ€™s limitation. 

However, there is a challenge arising from the inherent limitation of symbolic
execution\cite{symex-limit}, namely the path explosion problem. Which is if there is too many
possible path to go, symbolic execution can not solve the relations between
variable. And this occur if there is several path in control flow. 

To address this, we apply symbolic execution only within basic blocks rather
than across entire functions.
